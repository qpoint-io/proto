# -*- coding: utf-8 -*-
# Generated by https://github.com/connectrpc/connect-python.  DO NOT EDIT!
# source: eventstore/v1/main.proto

from collections.abc import AsyncIterator, Iterable, Iterator, Mapping
from typing import Protocol

from connectrpc.client import ConnectClient, ConnectClientSync
from connectrpc.code import Code
from connectrpc.errors import ConnectError
from connectrpc.interceptor import Interceptor, InterceptorSync
from connectrpc.method import IdempotencyLevel, MethodInfo
from connectrpc.request import Headers, RequestContext
from connectrpc.server import ConnectASGIApplication, ConnectWSGIApplication, Endpoint, EndpointSync
import eventstore.v1.main_pb2 as eventstore_dot_v1_dot_main__pb2


class EventStoreService(Protocol):
    async def ping(self, request: eventstore_dot_v1_dot_main__pb2.PingRequest, ctx: RequestContext) -> eventstore_dot_v1_dot_main__pb2.PingResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    def ingest(self, request: AsyncIterator[eventstore_dot_v1_dot_main__pb2.IngestRequest], ctx: RequestContext) -> AsyncIterator[eventstore_dot_v1_dot_main__pb2.IngestResponse]:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    async def ingest_batch(self, request: eventstore_dot_v1_dot_main__pb2.IngestBatchRequest, ctx: RequestContext) -> eventstore_dot_v1_dot_main__pb2.IngestBatchResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class EventStoreServiceASGIApplication(ConnectASGIApplication):
    def __init__(self, service: EventStoreService, *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/eventstore.v1.EventStoreService/Ping": Endpoint.unary(
                    method=MethodInfo(
                        name="Ping",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.PingRequest,
                        output=eventstore_dot_v1_dot_main__pb2.PingResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ping,
                ),
                "/eventstore.v1.EventStoreService/Ingest": Endpoint.bidi_stream(
                    method=MethodInfo(
                        name="Ingest",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.IngestRequest,
                        output=eventstore_dot_v1_dot_main__pb2.IngestResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ingest,
                ),
                "/eventstore.v1.EventStoreService/IngestBatch": Endpoint.unary(
                    method=MethodInfo(
                        name="IngestBatch",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
                        output=eventstore_dot_v1_dot_main__pb2.IngestBatchResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ingest_batch,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/eventstore.v1.EventStoreService"


class EventStoreServiceClient(ConnectClient):
    async def ping(
        self,
        request: eventstore_dot_v1_dot_main__pb2.PingRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> eventstore_dot_v1_dot_main__pb2.PingResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Ping",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.PingRequest,
                output=eventstore_dot_v1_dot_main__pb2.PingResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def ingest(
        self,
        request: AsyncIterator[eventstore_dot_v1_dot_main__pb2.IngestRequest],
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> AsyncIterator[eventstore_dot_v1_dot_main__pb2.IngestResponse]:
        return self.execute_bidi_stream(
            request=request,
            method=MethodInfo(
                name="Ingest",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.IngestRequest,
                output=eventstore_dot_v1_dot_main__pb2.IngestResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    async def ingest_batch(
        self,
        request: eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> eventstore_dot_v1_dot_main__pb2.IngestBatchResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="IngestBatch",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
                output=eventstore_dot_v1_dot_main__pb2.IngestBatchResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )


class EventStoreServiceSync(Protocol):
    def ping(self, request: eventstore_dot_v1_dot_main__pb2.PingRequest, ctx: RequestContext) -> eventstore_dot_v1_dot_main__pb2.PingResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
    def ingest(self, request: Iterator[eventstore_dot_v1_dot_main__pb2.IngestRequest], ctx: RequestContext) -> Iterator[eventstore_dot_v1_dot_main__pb2.IngestResponse]:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
    def ingest_batch(self, request: eventstore_dot_v1_dot_main__pb2.IngestBatchRequest, ctx: RequestContext) -> eventstore_dot_v1_dot_main__pb2.IngestBatchResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class EventStoreServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: EventStoreServiceSync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/eventstore.v1.EventStoreService/Ping": EndpointSync.unary(
                    method=MethodInfo(
                        name="Ping",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.PingRequest,
                        output=eventstore_dot_v1_dot_main__pb2.PingResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ping,
                ),
                "/eventstore.v1.EventStoreService/Ingest": EndpointSync.bidi_stream(
                    method=MethodInfo(
                        name="Ingest",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.IngestRequest,
                        output=eventstore_dot_v1_dot_main__pb2.IngestResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ingest,
                ),
                "/eventstore.v1.EventStoreService/IngestBatch": EndpointSync.unary(
                    method=MethodInfo(
                        name="IngestBatch",
                        service_name="eventstore.v1.EventStoreService",
                        input=eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
                        output=eventstore_dot_v1_dot_main__pb2.IngestBatchResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.ingest_batch,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/eventstore.v1.EventStoreService"


class EventStoreServiceClientSync(ConnectClientSync):
    def ping(
        self,
        request: eventstore_dot_v1_dot_main__pb2.PingRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> eventstore_dot_v1_dot_main__pb2.PingResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Ping",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.PingRequest,
                output=eventstore_dot_v1_dot_main__pb2.PingResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def ingest(
        self,
        request: Iterator[eventstore_dot_v1_dot_main__pb2.IngestRequest],
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> Iterator[eventstore_dot_v1_dot_main__pb2.IngestResponse]:
        return self.execute_bidi_stream(
            request=request,
            method=MethodInfo(
                name="Ingest",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.IngestRequest,
                output=eventstore_dot_v1_dot_main__pb2.IngestResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def ingest_batch(
        self,
        request: eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> eventstore_dot_v1_dot_main__pb2.IngestBatchResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="IngestBatch",
                service_name="eventstore.v1.EventStoreService",
                input=eventstore_dot_v1_dot_main__pb2.IngestBatchRequest,
                output=eventstore_dot_v1_dot_main__pb2.IngestBatchResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )
